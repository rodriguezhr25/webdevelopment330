<!DOCTYPE html>
<html lang="en">

<head>
    <title>Hector Rodriguez WDD 330 portfolio</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../css/styles.css" />
    <link rel="shortcut icon" href="http://sstatic.net/stackoverflow/img/favicon.ico">
</head>

<body>
    <header>
        <h1>WDD 330 portfolio</h1>
    </header>
    <main>

        <h1>Notes</h1>

        <h2>The Importance of Testing and Debugging</h2>

        <p> Make the code fail gracefully (although not completely silently ― we still need to know there’s an error), so the user experience is not affected, if possible.</p>

        <h3>Strict Mode</h3>
        <p>
            Produces more exceptions and warnings and prohibits the use of some deprecated features. This is due to the fact that strict mode considers coding practices that were previously accepted as just being 'poor style' as actual errors.
        </p>
        <h3>The Trusty Alert </h3>
        <p>
            The most basic form of debugging is to use the alert() method to show a dialog at certain points in the code.

        </p>
        <h3>Using the Console</h3>
        <p>
            Most modern JavaScript environments have a console object that provides a number of methods for logging information and debugging.
        </p>
        <h3>Error Objects</h3>
        <p> An error object can be created by the host environment when an exception occurs, or it can be created in the code using a constructor function, like so:
            </br>
            </br> const error = new Error();</p>
        <h3>Try , catch , and finally</h3>
        <p>
            If we suspect a piece of code will result in an exception, we can wrap it in a try block. This will run the code inside the block as normal, but if an exception occurs it will pass the error object that is thrown onto a catch block.
            </br>
            </br> function imaginarySquareRoot(number) {
            </br> 'use strict';
            </br> try {
            </br> return String(squareRoot(number));
            </br> } catch(error) {
            </br> return squareRoot(-number)+'i';
            </br> }
            </br> }
            </br>
            </br> A finally block can be added after a catch block. This will always be executed after the try or catch block, regardless of whether an exception occurred or not.
            </br>
            </br> function imaginarySquareRoot(number) {
            </br> 'use strict';
            </br> let answer;
            </br> try {
            </br> answer = String(squareRoot(number));
            </br> } catch(error) {
            </br> answer = squareRoot(-number)+"i";
            </br> } finally {
            </br> return `+ or - ${answer}`;
            </br> }
            </br> }

        </p>
        <h2>Questions</h2>
        <ol>
            <li>What are the best practices to handle errors on JS?</li>
            <li> How can we combine the JS validations and errrors handling with the backend? </li>

        </ol>
    </main>
    <footer>
        <p>&copy; <a href="../index.html"> Hector Rodriguez </a>| Venezuela | <a href="https://www.byui.edu/online">BYUI
                Online Learning</a></p>


    </footer>

</body>

</html>